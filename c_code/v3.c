#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// Function to encrypt/decrypt data using XOR
void xor_encrypt(char *data, size_t data_len, char *key, size_t key_len) {
    for (size_t i = 0; i < data_len; i++) {
        data[i] ^= key[i % key_len];
    }
}

// Function to read file content
char* read_file(const char *filename, size_t *size) {
    struct stat st;
    if (stat(filename, &st) != 0) {
        perror("Failed to get file status");
        return NULL;
    }

    if (S_ISDIR(st.st_mode)) {
        DIR *dir = opendir(filename);
        if (!dir) {
            perror("Failed to open directory");
            return NULL;
        }

        struct dirent *entry;
        while ((entry = readdir(dir)) != NULL) {
            // Skip the "." and ".." entries
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
                continue;
            }

            // Construct the full path of the file
            char path[PATH_MAX];
            snprintf(path, sizeof(path), "%s/%s", filename, entry->d_name);

            // Read and encrypt the file
            size_t file_size;
            char *file_data = read_file(path, &file_size);
            if (file_data) {
                xor_encrypt(file_data, file_size, "your_key", strlen("your_key"));
                // TODO: Write the encrypted data back to the file
                free(file_data);
            }
        }

        closedir(dir);
        return NULL;
    } else {
        FILE *file = fopen(filename, "rb");
        if (!file) {
            perror("Failed to open file");
            return NULL;
        }

        fseek(file, 0, SEEK_END);
        *size = ftell(file);
        fseek(file, 0, SEEK_SET);

        char *buffer = (char*)malloc(*size);
        if (!buffer) {
            perror("Failed to allocate memory");
            fclose(file);
            return NULL;
        }

        fread(buffer, 1, *size, file);
        fclose(file);
        return buffer;
    }
}