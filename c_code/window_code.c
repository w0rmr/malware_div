#include <windows.h>
#include <bcrypt.h>
#include <stdio.h>

#pragma comment(lib, "bcrypt.lib")

#define NT_SUCCESS(Status)          (((NTSTATUS)(Status)) >= 0)
#define STATUS_UNSUCCESSFUL         ((NTSTATUS)0xC0000001L)

void PrintHex(BYTE* data, ULONG dataLen) {
    for (ULONG i = 0; i < dataLen; i++) {
        printf("%02x", data[i]);
    }
    printf("\n");
}

int main() {
    BCRYPT_ALG_HANDLE       hAesAlg = NULL;
    BCRYPT_KEY_HANDLE       hKey = NULL;
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    DWORD                   cbData = 0, cbKeyObject = 0, cbBlockLen = 0, cbBlob = 0;
    PBYTE                   pbKeyObject = NULL, pbIV = NULL, pbBlob = NULL;
    BYTE                    rgbIV[16] = {0};
    BYTE                    rgbPlaintext[16] = "Hello, world!";
    BYTE                    rgbCiphertext[16] = {0};
    BYTE                    rgbKey[16] = {0};

    // Open an algorithm handle
    if (!NT_SUCCESS(status = BCryptOpenAlgorithmProvider(&hAesAlg, BCRYPT_AES_ALGORITHM, NULL, 0))) {
        printf("BCryptOpenAlgorithmProvider failed with status: 0x%08x\n", status);
        goto Cleanup;
    }

    // Generate a random key
    if (!NT_SUCCESS(status = BCryptGenRandom(NULL, rgbKey, sizeof(rgbKey), BCRYPT_USE_SYSTEM_PREFERRED_RNG))) {
        printf("BCryptGenRandom failed with status: 0x%08x\n", status);
        goto Cleanup;
    }

    // Get the block length
    if (!NT_SUCCESS(status = BCryptGetProperty(hAesAlg, BCRYPT_BLOCK_LENGTH, (PBYTE)&cbBlockLen, sizeof(DWORD), &cbData, 0))) {
        printf("BCryptGetProperty failed with status: 0x%08x\n", status);
        goto Cleanup;
    }

    // Allocate the key object on the heap
    pbKeyObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbKeyObject);
    if (NULL == pbKeyObject) {
        printf("Memory allocation failed\n");
        goto Cleanup;
    }

    // Generate the key from supplied input key bytes
    if (!NT_SUCCESS(status = BCryptGenerateSymmetricKey(hAesAlg, &hKey, pbKeyObject, cbKeyObject, (PBYTE)rgbKey, sizeof(rgbKey), 0))) {
        printf("BCryptGenerateSymmetricKey failed with status: 0x%08x\n", status);
        goto Cleanup;
    }

    // Perform the encryption
    if (!NT_SUCCESS(status = BCryptEncrypt(hKey, rgbPlaintext, sizeof(rgbPlaintext), NULL, rgbIV, cbBlockLen, rgbCiphertext, sizeof(rgbCiphertext), &cbData, BCRYPT_BLOCK_PADDING))) {
        printf("BCryptEncrypt failed with status: 0x%08x\n", status);
        goto Cleanup;
    }

    printf("Ciphertext: ");
    PrintHex(rgbCiphertext, sizeof(rgbCiphertext));

Cleanup:

    if (hAesAlg) {
        BCryptCloseAlgorithmProvider(hAesAlg, 0);
    }

    if (hKey) {
        BCryptDestroyKey(hKey);
    }

    if (pbKeyObject) {
        HeapFree(GetProcessHeap(), 0, pbKeyObject);
    }

    return 0;
}
